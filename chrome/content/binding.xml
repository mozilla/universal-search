<?xml version="1.0"?>
<bindings id="universal-search"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
  <binding id="recommendation-popup" extends="chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup">
    <content ignorekeys="true" level="top" consumeoutsideclicks="never" aria-owns="richlistbox">
      <xul:hbox id="universal-search-recommendation" collapsed="true"/>
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox" flex="1"/>
      <xul:hbox anonid="footer">
        <children/>
      </xul:hbox>
    </content>
    <implementation>
      <field name="_selectedIndex">-1</field>
      <property name="selectedIndex">
        <getter>
          return this._selectedIndex;
        </getter>
        <setter><![CDATA[
          // This function sets the selected item in the results list.
          // The selected item has a blue highlight.
          // Setting selectedIndex to -1 will unselect all results.
          // `val` is the value passed to the setter.

          var resultsContainer = document.getAnonymousElementByAttribute(gURLBar.popup, 'anonid', 'richlistbox');

          // NOTE: getElementsByClassName is needed to obtain a live NodeList.
          // The results aren't inserted all at once: they are inserted one
          // at a time over many successive turns. In order to avoid setting
          // the selectedIndex past the end of the results list, and also to
          // avoid mistakenly concluding that the results list is empty, the
          // NodeList needs to be live, not static.
          var resultRows = resultsContainer.getElementsByClassName('autocomplete-richlistitem');

          if (!resultRows || !resultRows.length) {
            return;
          }

          if (val > resultRows.length - 1) {
            val = resultRows.length - 1;
          } else if (val < -1) {
            val = -1;
          }

          // Unselect all the rows (in case of any weird multiple-focus bugs),
          // then immediately select the appropriate row, to hopefully batch
          // the selection changes into a single DOM update.
          Array.prototype.forEach.call(resultRows, function(row, i) {
            row.selected = false;
          });

          // Highlight the row, if it's found, else highlight nothing.
          if (resultRows[val]) {
            resultRows[val].selected = true;
            // Scroll the row into view, if necessary.
            resultsContainer.ensureIndexIsVisible(val);
            this._selectedIndex = val;
            return val;
          } else {
            this._selectedIndex = -1;
            return -1;
          }
        ]]></setter>
      </property>

      <field name="tree">
        document.getAnonymousElementByAttribute(this, "anonid", "tree");
      </field>

      <method name="getNextIndex">
        <parameter name="reverse"/>
        <parameter name="amount"/>
        <parameter name="index"/>
        <parameter name="maxRow"/>
        <body><![CDATA[
          // The urlbar stops working if this method is not implemented here.
          // This implementation doesn't handle certain edge cases, like
          // scrolling off the top or bottom of the list, but whatever code
          // calls this code doesn't seem to hit that bug.
          let realAmount = amount % maxRow;
          this._selectedIndex = reverse ? this._selectedIndex - realAmount: this._selectedIndex + realAmount;
          return this._selectedIndex;
        ]]></body>
      </method>
    </implementation>
  </binding>

  <binding id="recommendation-urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar">
    <handlers>
      <handler event="keypress" phase="capturing"><![CDATA[
        // If the urlbar handles the event, it returns true. Else, it returns
        // false, and the existing XBL key handlers handle the key event.
        return window.universalSearch.urlbar.onKeyPress(event) || this.handleKeyPress(event);
      ]]></handler>
    </handlers>
  </binding>
</bindings>
